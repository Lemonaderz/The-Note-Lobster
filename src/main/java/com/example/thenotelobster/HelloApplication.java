package com.example.thenotelobster;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.layout.*;
import javafx.stage.Screen;
import javafx.stage.Stage;
import javafx.scene.control.*;

import java.io.IOException;
import java.sql.*;

public class HelloApplication extends Application {

    public static final String TITLE = "The Note Lobster";
    static Rectangle2D screenSize = Screen.getPrimary().getVisualBounds();
    public static final int WIDTH = (int) screenSize.getWidth();
    public static final int HEIGHT = (int) screenSize.getHeight();


    @Override
    public void start(Stage stage) throws IOException {
        FXMLLoader fxmlLoader = new FXMLLoader(HelloApplication.class.getResource("login-view.fxml"));
        Scene scene = new Scene(fxmlLoader.load(), WIDTH, HEIGHT);
        String stylesheet = HelloApplication.class.getResource("stylesheet.css").toExternalForm();
        scene.getStylesheets().add(stylesheet);
        stage.setTitle(TITLE);
        stage.setMaximized(true);
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {

        AIManager manager = new AIManager();

        // EXAMPLE HOW TO USE AIManager
//        manager.fetchPromptResponse("summarize this: Today, we want to discuss a very important aspect of enterprise systems development from a coding point of view, really, which is object oriented programming. I believe many people are familiar with OOP. For example, if you are in computer science or you know Java or CSA programming, you probably are familiar with that. Object oriented programming is a very important aspect of enterprise system development because previously we have talked about business objects. Everything in a business is looked at through the lens of an object. But it is also important to understand how you can instantiate these objects from a programmatic point of view. That is what we want to talk about today. What is OOP. Technically, Through the lens of OOP, programmers see everything as an object, a cheer, a person, invoice from a business point of view, even a flower, an animal. So each one of these have characteristics. So for example, a person have skin turn, a person have height, they have weight, and then you look at it from another perspective, from a behavioural point of view, a person can speak. A animal can walk, they can talk. This could be seen from a method point of view. Object programming is more like a paradigm that gives programmers the ability to view entities through an object lens. So we will look at some examples in our own context, as well as how they can be applied from an enterprise systems context. There are a few key concepts. When we talk about object oriented programming, there are a few key concepts that you cannot do without, which is the concept of classes and objects. We've talked about objects, but classes are from a programmatic point of view. Then there's cocation, inheritance, polymorphism, as well as abstraction. We will touch on some of these as we progress in our discussion today. So Let's look at what is an object. Now, when we talk about object, like I said, we're talking about entities that have attributes or characteristics. So what do you mean by attributes? Attributes are like your properties, your height, the colour of your skin, attributes are like your weight. If you look at it from a business object point of view, we'll see name, a student has a name. A students have an ID, an e mail address, a location, address, and so on. So those are attributes. So objects they are different viewpoints from an object point of view. So you can see different authors have come up with different definitions of what they conceive an object to be. So Code and Udon talks about object as an abstraction of something in a problem domain reflecting the capabilities of a system to keep information about it, interact with it, or bod. And then you also see others who view it as a collection of data and associated behaviours. From an enterprise system point of view, you could view object as the later definition, which is basically a collection of data, and then the behaviours. So we're looking at information that is stored in a database, and then what those entities can do and what actions can be performed on those entities. So let's look at a typical example which from a business point of view, we all know, which is a customer. In the business domain, one of the key objects within any business information system or management information system is the customer. So you want to capture information about the customer. The customer will have attributes or the object data, as we refer to it. So we have the customer ID, the first name and last name, e mail phone, and any other information you want to capture about the customer. Then there are also object behaviours. These are actions that the object can perform, or in some cases, actions that can be performed on those objects. So here we see the customer can place order. The customer can also make payment and order. Behaviours that can be associated with a customer. So Put it simply and object represents an entity within either a software development context or a business context. Let's look at the difference here. If you recall, we have talked about business object, which is one of the things you're doing in your assessment. But how is it different from object from a generic computer science or programming point of view? So business objects are business driven. So these are entities that are real word entities from a business point of view. Your customers, your invoice, your order, all of those are business related. So that is one of the key differences between the objects from a software point of view and then the objects from a business point of view. So the objects in a business context are business driven. So in most cases, they are seen from a domain point of view. So they store records in the database, also are used to manipulate or to develop business processes, as the case may be. So they serve as higher level abstraction for modelling business operations. So they are not typically seen from a technical implementation point of view. But from a software point of view, you see an object They are basically instances of classes that carcelate data and behaviour. Anything can be conceived as an object from a software point of view. Then objects in a software domain are not typically associated directly with database tables. When we talk about objects in a in a business point of view, these are information that businesses store, and then they can retrieve those information and do something with it at a later date. But you can have your object from a software point of view, which are just programmatically defined. But here, these are basically reward entities that businesses interact with on daily basis. These are a couple more differences between the objects in OOP as well and then business objects. If you look at it from a proposed scope implementation point of view, you will see a few differences that exist between business objects and software objects. Any questions at this point? All right. So you cannot talk about objects without talking about classes. Now, I believe some persons probably did wonder when we're talking about business objects, and then we talked about business object modelling. And then the diagrams looked like a class diagram. Why didn't we call them class diagrams. We didn't call them class diagrams because we are talking from an enterprise application perspective. So from a business context, we look at those as objects, not classes. So we talk about classes from a programmatic sense. So when we're talking about programmes, you define classes, methods, class attributes, and so on, that is from a programmatic point of view. But if you're looking at it from an enterprise system or from a business point of view, you look at the trade lines of an object. So in most cases, from an enterprise system point of view, the objects are used to instantiate classes, or the classes would have to instantiate objects within the business domain. So a class is typically, there are different definitions you probably might see, but a class is like a template. That I think is the most simplest definition. It's like a template for an object. So look at a class as Your building plan. So to build a house or direct a building, you need to have a plan. It is from that plan that the house is designed. So you can design multiple houses based on one single plan. That is what a class is. For those of you who make cookies at home, look at the class as the cookie cutter, basically. You can have multiple cookie cutters that different shapes of cookies from the same cookie dough. So that is typically what a class is. A class is like a template. It defines the name, the attributes, as well as the behaviour of object. It is from this class template that we create or instantiate an object. So if we have a class, say a customer class that defines the attributes of a customer to include the ID, the first name, last name, e mail, and phone. Then each time we instantiate or we want to create an object, a customer object, say customer one, a customer two, whatever customer instantiation we want to create. So that would have to be formed based on the definition contained within the class. So to better understand the class, let's look at this. Let's say you have a cook, and you need to You need to create multiple cookies. The cookies are the objects. But the cookie cutter is your class template. It is what is used to cover different shapes. You can have different shapes of cookies cut out from the same dough. That is typically how a class. You define a class and then you create objects based on the definition of the class. So Let's look at how you create a class or an object from a class. Let's say we have our customer class. And we have defined that our customer class has about five attributes, a customer ID, a first name, last name, e mail, and a phone. So this is our template. We can use this template to create different customers. So One customer will be customer 0001 with customer ID 0001, first name John, last name, e mail John do at email.com, and then a phone number. So we can also create another object from this particular template. So here we have our customer ID to be 0002. First name look, last name Happer, e mail, and then phone. So we could create as many instances of this class as possible, which are typically objects. So if you look at the learning management system that many universities use, there are multiple students that the information is stored in those systems. So typically, there is a student class that each time a student enrols into the university, a record of the student is created. So what record is created is determined by the template, which is the class. So what information is supposed to be contained or the entities or the attributes that are contained within the class definition determines what information is going to be required from a student record point of view. And questions from here. We've talked about objects and classes from a very generic point of view. We want to look at this from a language specific lens. All this while we've been talking about APEX programming language. This is how a class is defined in e. Now, what you see on top here, Those are the assess modifiers. Assess modifiers can be private, public, or global. Now, private is basically when you don't want that particular class to be instantiated from outside of your organisation. You can make it public, for example, if you want to expose it, or you can make it global. Global in EPE is used mostly if you want to expose a class as a web service. So we will do web services when we talk about APIs, which will also feature in one of the tax in your assignment two. So each class, when you want to expose a class as a web service, it must be defined as global using the assess modifier global. We will look at that at a later date. Then you can also have sharing modes, There are different sharing most virtual abstract, with sharing without sharing. Now, this may not apply in some other programming languages, but in APEX. You see that this are very much common across many object oriented languages. Java, C sharp, and the rest. But with sharing and without sharing, I think is a bit more specific to the EPEC programming language. But what does each one of these mean? I'm sure you probably if you're familiar with Java and C sharp, you understand that the virtual So when you want to override a class or override a method within a class, you can then define that method or class as a virtual method so that you can write a different implementation of that particular method or class. But with sharing and without sharing works a little bit differently in APEX. When you define a class with sharing, it means that you're limiting that particular class or the behaviour of that class to the users access level. Each time a user creates a class. Whatever access level you have on that particular system would determine the behaviour of your class. For example, if you create a class and you define it with sharing and as a user, you can only change 30 or 20 records at a time. So let's say you have defined a class or a procedure within the class to effect 50 records But the user access level only limits that particular user to 20 or 30 records. That class that operation will only be limited to the number of assets or the number of operations that the user can perform based on their assess level. This is called user mode with sharing. It inherits the access level of the user, and then that determines the behaviour of the class. If you define it without sharing, that is a system mode, in which case, regardless of what access level the user may have, then the class will perform the functions or the operations that are specified within without any limitations based on the access level. Then within a class, we have a class name as well as the body of the class. This is basically the syntax for defining a class. Each one of these Access modifiers and sharing modes have different functions? The private, the public, the global, like I said, mostly used when you're creating we services, and then you have the with sharing without sharing, as well as virtual when you want to override a class, then you have to define that class as a virtual class so that you can create a separate implementation of the class maybe in a different context. Any questions from here? The other thing is within a class, we can also have multiple methods. A method defines the behaviour of an object. Whether you want to add records, delete records, and so on, those are defined within methods. In EF, Methods are defined using this particular syntax. You see the access modifiers, whether it is public, private, protected, or global. Then you can you can also define it as either override, static over varieties, basically when you're overriding a particular virtual method that is defined in a different class. And then you have the type, which is the return type. Now, methods can have no return type, in which case it is a void method. Then you can also have a specific return type, which case you have to define the data type that it's going to return. Could be a string, a decimal, a bulion, or whatever data type that you want to return. Then you have the parameters. The parameters, in some cases, could take as long as 32. That's the most method can take in PEX. But you can also have no parameters at all, in which case, you have to include an empty bracket. So this is a typical method. So a public static integer. So the data type here is integer. So it is returning a value, which is of the integer type. This is the method name, and then you can do some calculations or implementations in the co braces. So within the cobrass, you can define how this particular method is going to behave. Many operations that are performed with you're deleting, you're checking when someone deletes a record, you want to check If they actually meant to delete that record, those are basically defined within methods. Another important concept when it comes to class and method definition is constructors. What are constructors? In object oriented programming, one of the things we talk about is your ability to instantiate. So we looked at a class as a template. But how do you create programmatically, how do you create an object of that template? You need to instantiate that particular class. What helps you to instantiate the class the constructors. By default, we have the new argument constructor, which is basically a method with the same name as the class name. So here you can see public order, and then we have a class public class order. So the method name has the same name as the class name. Sometimes you can define how this particular constructor behaves. But if you do not define a constructor, it takes the default form, which is the no argument constructor. So that is why each time you instantiate a class, you can use the dot notation to retrieve the attributes within the class instance variables, and then you can assign the method or the object its properties by using the dot notation. So what allows you to do that is the new argument constructor. Now there are also times when you want to define a specific number of constructors or a specific number of parameters within your constructor. So that's where you have the overloaded constructor. First, here we have the new argument constructor, and then here, you can see that we have same method and class name. So this is a constructor. This is another constructor, but the difference between the first and the second is that in the second, we have the constructor, we have assigned the constructor two parameters, a string parameter and a date parameter. Here we have overloaded this this constructor. What it means is that when you're trying to instantiate an order, you have to assign or specify the order ID and the order date. So each time you instantiate an order, you have to define or specify the ID, that's the order ID, and then the order date. So we've enable to these instant variables, which are the order number and the order date. So these instant variables here are equal to the parameter variables that we've passed to the overloaded constructor here. And then we're saying that these two variables here are also equal to the two variables we've passed in the overloaded constructor. Any questions here? So let's look at a class holistically. So we've talked about class names, constructors, as well as class methods. So putting all that together, we can have an or class with all the attributes, other ID, or date, total amount. These are the attributes we see in the class diagram, where we specify that an order can have an order ID, can be identified by the date of the order or associated with a total amount. And then we have a constructor, which is an overloaded constructor in which case we've passed three parameters, the order ID, the order date, and the total amount. Now, we've used the D keyword to reference these parameters here. Refer these attributes and then equate them to the parameters with pass in the order. What does that mean? Because we have or ID, the same name as the order ID in the parameter list. We need to be able to differentiate which one we are referring to. If we have them as different names here, and then we want to equate each name. So for example, let's say we have or number. And then here we have or ID. We can say or number is equal to other ID. That would be okay. But because we have the same instance variables that we've defined, same name with the parameter list that we've passed to this constructor, then we have to use the diskey word. The dis keyword down now refers to the instance variables. This the instance variable is equal to the parameter variable. So that is why we're using the ds. Otherwise, you can equally since we have defined the instant variables here, we can just say other ID que other ID. But because their names are the same, we can do that, so we have to be able to differentiate which one is which ones are the instant variables and which one are the parameter variables. And then this is a method, in which case, which saying display other details. Here we're trying to print Other ID is going to print an order ID. So the four slash and is a new line, which means each one of these will be printed in a separate line. These are the methods, we have our constructors, we have our attributes of the fields, we have the class name as well as the modifiers. In which case, this is a public class. Any questions? Here. Okay. Let's look at instantiating an object. If you look here, we have our order, and we've defined an order with three instant variables, order ID, order date, and total amount. We have a constructor that we have also defined. Which takes three arguments, O ID, other date, and total amount. And then we have another method which have defined to print or to display the details of the order. Let's say we have our first order. So the order date is OLD 001, and then we're saying the date is today, and the total amount is 250. In order to instantiate that particular class to create our object record, we have to say the class name followed by the name of the object. You can say the class name here is order. So we have to have to include the class name followed by the order name. Now, the name here can be anything. So long as it's associated with a class and then followed by a new order, which is basically a new instantiation of this particular constructor. You can see because we have a parameterized constructor that takes three parameters, we are passing three values here. The first value is the order ID, second value is the date, and then the third value is the total amount. We have two order records and we've been able to pass that or to create an instance of that class Using those values. Here, we're using the dot notation to retrieve. We're saying or do order ID. So this definitely will print out the order ID for order one. And then we're saying 02 dos or date, in which case is going to print this particular date here. So next we are calling, so we're using the dot notation also to call the display order details. Here is the display order detail. Once we have created an instance of this class, we can then use that to reference any of the methods that are defined within the class. So here we're calling the display order details, which has a print method or a print statement rather that prints out the order ID, the order date, and the total amount in a new line. So the first order will print this. The second one will print that. That's how you instantiate an object from a class definition. So you state the name of the class followed by the name of the method, and then you create a new instance of the class. If if the constructor is parameterized, then you have to define the values for the parameters. Otherwise, you can use the dot notation to assign different values to the object based on whatever value you have specified in your programme. Any questions here? Okay. The next thing we want to discuss is the concept of messages. In our previous discussion, when we talked about business objects. We talked about interaction diagrams, which is basically you see business objects or different entities, how they interact within a system. So one sending message and then the other responding with a response. So methods also do the same. When we have multiple methods within a particular system, what definitely happens is that we're passing or we're sending message from one method to another method. So we want to retrieve a particular order number, or we want to retrieve the D of a person or a student. We're passing or we're creating an instance of a method and we are calling a method that is defined in a separate class. So that is a message that we're sending to that method, and then that method we have to execute and return a response. So that is how messages work. Look at this particular instance. Let's say we have an order class and then a product. We're trying to purchase an item, but or we're trying to design a system that allows a user to add a product to an order. In order to do that, so we have our order class and our product class. And in the product class, we have defined how to add a product. In order to add that product to our order, we have to call that method within the product class. This is typically some of the message exchanges. So an order would have to add the product as well as get the price, and then the product we have to return the price as well as update the total amount because the price is within the product class. Let's look at it from an EP programme point of view. Here we have order and product classes, as we saw in the previous slide. We defined two instance variables, the order ID and the total amount. The total amount, we have initialised it to zero. In the other class, we have another method called add product. Then we also have another method called get total amount. Here, add product, this is the behaviour of this particular class, and then get price, which is basically trying to re the price of a product. If we look at the product class, we also have two variables, product ID and price, and then we have a constructor which instantiates a product. So each time we want to create a product, we have to use this constructor to create a product instance. So this instantiates the product, and then we have another that gets the price of the product, which is basically returning the price of or whatever price that you defined for the product. So if you look here, When we instantiate this particular, the two classes. We have an instance of a product, product one, and we're passing the product ID and the price because that is the definition. And then we have our order, which is the order ID here. Sorry. So you can say we're adding a product, and we have just one single parameter for this particular art product method. Here we are instantiating the two classes. The product class and the order class, and then we are calling. The order is sending a message to product. You can see the ad product has a parameter called product one, which is the one we have defined here. And this is defined in the product class. The product the constructor that creates the particular product is defined here. Is defined here. This is where the product is defined. In order for us to add the product, we need to first of all, create an instance of that particular product. So here, the order is calling the ad product and which sends a message to the product to add a product to the order. And then here we are then printing out the product, so you can see product one dot get total amount. Get total amount is also another method within the or class. So you can see the back and fort, how object sent or method send messages to another method, which we then return a response. When we call up, when we send a message from when the order sends a message to the product, the product will have to instantiate this particular product and then add that product to the a product method, which is defined within the order class. Any questions here? Next up, we're going to discuss how you implement classes and methods using a sample application. Before that, I will let you go for a 5 minutes break. So when we come back, we continue. The next thing we want to discuss is a typical implementation using a sample hotel application scenario. Previously, we have looked at different objects within a hotel application app, a guest, a reservation, a room, and some other objects. We'll just pick this three for reference proposes. If you look here, you'll see that we have a guest Object has about four attribute, guess ID, first name, last name and phone? We have a reservation object, which has a guess name, checking date, checkout date, and then information about the room. We also have a room object, which has a room ID, the type of room, and then the price of each room. So how do you instantiate each one of these as an object? Programmatically. This is the first. First of all, each one of them would you have to create a class for each object, a guest class, a reservation class, and then a room class. To create a room class, we have to start with the public. Now normally, this is optional, but if you don't include it, I think it will take the private Identifier. So here we have a class definition. We have the instant variables as the room number, the type of room, and the price of the room. And then we have a constructor that defines how this room would have to be instantiated. So we are passing three parameters here, the room number, the type of room and the prize of each room. Then we're using the dis keyword to relate the instant variables to the parameter variables. This is basically a room class. Now you can also define further methods that perform different actions depending on what you want to achieve. The other thing is our guest class. Now, in the guest table, we have a guest ID, first name, last name and phone. Here, we have those as instant variables. Here, we have a guest ID, first name, last name and the phone. And then we have a constructor that defines how this particular guest would have to be instantiated. And then we have displayed guest info that defines how the guest information is going to be displayed on the console. The other thing is further, we have a reservation class. So each of the objects are now classes in our programme. So we have the instant variables, which are the attributes or the characteristics of this particular reservation, guest ID, checking date, checkout dates, and room. And then we have a constructor as well as a display reservation method that displays information about the reservation. So putting all that together, we can then instant shear a different object. So we have a guest, so we're creating a new guest, and then we are passing the guest ID, the first name, last name, and the phone. We are creating new rooms. So we have to state the class name followed by the method name, which in this case is room one oh one, and then we instantiate a new room and then we pass the parameters we specified in the constructor, which is the room number, or the room ID, the type, and then the price. Same thing with a second instance of the room, which is room 102. Then we're adding, so we have this we have another hotel, which I did not include another hotel class, where we're adding these rooms to the hotel class, say add room method within the hotel class. And then we then have a reservation. A reservation, we then create a new reservation where we're adding the name, the date. Of the reservation. Now, in EPEC, if you want to create a date, it is called date dot today. So today's date. If you want to create yesterday's date, you have to subtract the number of days between today and that previous date. So it will be today minus say, for example, if you want to create a date from yesterday, it will be today minus date dot today minus one. So this will basically specify the date of today and then remove one day from today's date, which will give you yesterday's date. On a second. Then if you want to create a date in the future, so that will have to be the date. So today will be the reference date, and then you can add the number of dates from today up to that particular date. Yeah. Well, the room numbers are In some cases, they can be auto generated. That is if you have defined your object to auto generate room numbers. Otherwise, you can also generate the room numbers programmatically by manually or hard coding them. There are different ways to generate a room number. One way from what we've done so far, so you can create an object and then define that the room numbers are auto numbers. What that means is that each time and object is created, you don't have to manually create a room number. The system will auto generate that particular number and assign it to that room. So you don't have to do that. Another option is for you to hard code each room number. So here we're basically hard coding the room numbers. But under normal circumstances, you may decide not to hardcode the room numbers and then make them auto generated. Here then the last thing is basically we're displaying reservation information, which is calling this particular method. So we're using the reservation object to call my reservation, which is the object instance of this reservation class, and then we're calling the reservation to display the information about the guest name, the room number, check in date, as well as checkout date. This will be basically the output of this particular programme. So here is our guest instance of our guest one oh one, room one oh one, and then our reservation. Checkout date for this reservation is three days from today. Check in date is today. The other thing you can also do is extend a class. You could see here that we have multiple classes. But a class can be limited in function, and you can extend the classes at any point in time by adding either a new instance variable, a new method, and so on. Here you can see we have introduced a hotel class, in which case, we have the name of the hotel, the location, a list of rooms that are contained in the hotel. We've also introduced a rating the hotel as well as amenities that are contained within that particular hotel. And then we have a constructor which specify how we instantiate this particular class. We have another method that adds room to the hotel, and then we have another method that displays the hotel information, and then another method that gets the total number of rooms in that particular hotel. You can see we've added multiple methods to this particular class. This is the class definition, the instance variables, the constructor, and then three other methods, one to add the room, the other one to display the hotel info, and then the other one to get the total number of rooms for that particular hotel. The second thing we can also do is extend a room class. You can see here we've added another variable that checks whether the room is available. And then we've also added a view for that particular room. So there are rooms that have specific views, and those views might be one of the reasons people reserve them. So we've added the view here. And then here, we have a constructor that defines the room or how the room is instantiated. We have another method that display or that books a room. And then we have another method that displays the room information. So we can then try to instantiate the hotel and the room class using the extended classes. So here, first of all, we're creating an extended hotel object. We're creating an extended hotel room object, and then we're adding rooms to the hotel. We're displaying hotel info. We're displaying room info and booking a room. And then finally, we are getting the total number of rooms in the hotel. So this will give us these results. So the hotel is Sunrise in, Location is downtown, rating is f, amenities three wi fi, pool and gym. And then we have the display room information, which will display the information about the room, the type of room, the price, whether the room is available, the room view, and then also display whether the room is booked or not. So this is basically how you can extend a class and then instantiate that particular class by creating multiple objects and then using the instance of those objects to call the methods that are defined within the class. Any questions from here? Okay. If you have dealt with object oriented programming, one of the things you basically would have gone through at the different concept, the concept of inheritance, polymorphism, and so on. So we want to discuss a little bit of how those are implemented using the APEX programming language. So we talked about inheritance. I think we've looked at it from an object modelling point of view where you're using arrows to indicate whether a child object is inherited from a parent object. So inheritance gives you the ability not to reuse your code. So for example, Within the KeyT environment, everybody here is a person, whether you're a lecturer, a student, and the registrar, ahead of department, ahead of school, whatever role you play. There are some information that are common across every person. For example, there is a first name associated with someone, a last name, data ba, address, e mail, and so on those are generic, more like common attributes that can be associated with people. Now, depending on the role you play, If you are student, you have a student ID. If you are staff, you have a staff ID. So you can see student ID is specific to student, staff ID is specific to staff. If you are staff, you have salary from a payroll point of view, a student don't get paid. So all of that, Some of the things you have to take into account when you're creating a system and how you instantiate a particular system or inherit objects or classes within that particular system. You don't want to repeat. For example, you're creating a student class, a staff class, and so on, and then you're repeating all the attributes across all the classes. You can use inheritance to shorten or to reuse some of the codes. So you create a parent class that contains the base the common information that all common attributes, you can find across all the classes, and then you create the child classes that inherit the parent, but retain specific information for those particular classes or objects. So this is if you look at a room, for example, a room may have different types. A single room or a double room. Now, you'll see here that a room has information that is common regardless of what type of room, the number of the room, the type of room, and the price. This is common. But if it's a single room, You want to indicate the view, or if it's a double room, you want to indicate whether it has a balcony or not. So it means that a single room does not have a balcony, but a double room has a balcony. So to be able to indicate that or to check whether a room has balcony or not, basically has to be associated with a double room. And then you can creates a specific instantiation or specific implementation of the display room info. We have a method that displays specific single room information that is specific to the single room, and another method that is specific to the double room. These two methods are not the same, so we cannot put them here. Otherwise, if we put them in the room class, then both the single and double room will inherit them. What it means is that Regardless of the fact that we have these as separate from the room, the double room will inherit the attributes that are common to the room, which is the room number, the type and the price, as well as the single room inheriting all the common attributes and methods that are specified in the room, but retaining the specific methods that are specified in the child classes. This is the room the single room and the double room from an apex point of view. Here, we have a room. This is a normal room class. With three instance variable room number type and price, and then we have a constructor. Then we have a display room info. This is common to this two. Now, we have another class. We have a single room class, which is a subclass. This is the main class or the base class. We have another subclass which is this double room. In order to inherit or extend this particular class, in the child classes or the sub classes, you use the word extend. So extend we're extending the room class. So we say public class, single room extends room. What it means is that they will now be able to give the single room access to all the instance variables and methods that are defined in the base class, as well as double room. Then you can also see that we have display double room info, which is specific to the double room. We have display single room info, which is specific to the single room. These two methods are different. That is why they are contained separately in each of the subclasses. But the instance variables as well as the display room info are all available in case you want to call them from the subclasses. So this is typically how we can be able to instantiate, so we can create a single room object by calling the single room class followed by an object name in this case, single room. And then using the new keyword, we're instantiating a single room. And then we're displaying the single room information by calling this particular method here. The next, we're creating a double room object, and then we're displaying double room info by calling this particular method. I will display double room information. This will be the output of the two instantiations and display. Any questions here? The other OP concept, we want to talk about is encapsulation. Now, In your object diagram, we have told you not to use the visibility symbol, which is basically whether I include a minor surplus before an attribute name. That is typically a form of encapsulation. Here you can see if you look at the modifiers we mentioned earlier, which is whether it's public, private, virtual, global, and so on, those define encapsulation. You want to be able to hide the implementation of a particular method or class from someone else, so they won't be able to have access to see or to change how that particular method or class behaves. Here you can see the minus sign means a private attribute. The plus sign here denotes a public method. In some cases, you will also see attributes that are indicated using a plus sign, which indicates a public attribute. Now, if you do not indicate the modifier, in most cases, it will take a single a private state. Here you can see calculating a banking system. We have another example from a bank account. So we've defined these account number and balance. Now, in typical systems, you probably see fields that are read only. This is this is very much related to some of those fields that you see, they are read only, so you cannot modify them. For example, as a user, as a student, you cannot change your student number, even if you wanted. As a bank customer, you cannot modify your balance, even if you want it. So even if you want to assess the bank system through an API call, those are encapsulated because you cannot understand it. They kind of make it private so that you don't understand how or you don't modify those attributes, you don't modify the methods or how they behave. So here we're trying to encapsulate the implementation of some of these by declaring them as private. And then you can see some other methods here are defined as public, and then some attributes are defined as private because you don't want any system or any implementation from outside of your organisation to make changes to those parameters or those variables. The other thing is also using getters and setters. If you're familiar with C sharp, this is very much one of CSA features. Using getters and setters. Getters and Setters gives you the opportunity to manually define how a particular attribute is going to behave. So for example, you want to assign a value to an attribute after checking a particular condition. So the getters and setters will help you to do that. So the getters return information while the setters define a value for that particular attribute. If you look here, you will say We have a product class, we have defined the product name to be a private attribute. And then we have an explicit ga which returns, so you can see here. The product name is private, but we have a ga method that returns, which is now a public method that returns the name of the product. Ordinarily, you wouldn't be able to assess the product name directly from another application, but you can call the G product name in order for it to return the product name. Here, to be able to return this name, you can add additional logic. They are basically checks, different criteria, different conditions before returning the name. This gives the programmer control over how each of these methods behave. What happens, or what should happen before a product name is returned. You can also set a product name. Here you can see this does not just set a name, it first of checks if the product name is not null, and then the length of the product name is greater than zero. So if it is not null and then the length is greater than zero, then it will set the product name to whatever name that is passed on here. So it doesn't set a name if it has a name already. But it will first of all check if if the product name null, Is the name that you pass here greater than zero. So if you don't pass any record at all, it's not going to set an empty name. You have to first of all, check if you passed a name value. Also check if the product name is not null before it sets this name and then prints. Otherwise, product name cannot be empty. So first of all, if you have not passed any name here, then you get this message. Otherwise, it will set the name of the product. There are also automatic getters. Here you can see, these are explicit getters and setters. But you can have automatic gators, which is basically you create a method and you just put the gat and set. These are auto gas and setters. You don't need the auto implement. Now this is very a feature in CSA, if you're familiar with the programming language. So One other implementation that we want to talk about. This helps you to either. Now, if you don't have to define, if you don't have to define how each of these methods behave, you don't want to check a particular condition before assigning a value to a parameter or a variable, or you don't want to check a particular condition before returning the value of a variable, then you can use auto gatas and cts. Otherwise, you have to use explicit gas that gives you the control. Over how each one of these behave, when do you return them, when do you set the variables and so on. Any questions at this point? Okay, so we want to talk about polymorphism. I'm sure many of us have heard about polymorphism. Now, polymorphism in Apex is implemented mostly using the virtual modifier. You have different methods in different classes that behave or similar methods in different classes that behave differently. For example, you can say if we go back to our room object, and then we have a standard room and a suite. These are different types of rooms. This is the parent or the base class. These are the sub classes. We have a suite is a type of room, a standard room is a type of room. Then in the base class, we have attributes like room number type and price, and then we have a display room info. Typically, you can define this particular method as virtual, which means you don't have to technically write a full implementation of this method. You can overwrite the method in another class. So then we can then override this method. Overriding the method, we have to include the override keyboard. And then in which case, we want to you can see display room in display room info, display room info. Same method, but different signatures. Because the way we want this to happen, so we want each of the types of room to have a separate display. So they will be displayed separately depending on what information we want to display about the room. The standard room info display will be different from the suite room info display, but they have the same method name. By defining the display room info in the parent class as a virtual method, We can then override it, which is write a separate implementation of this method to behave one way for standard room and another way for a suite. So here, you can see a room class, a standard room class, with the three instance variable. A constructor, and then the method that displays room info. This is the method, and here we can see it's been defined as a virtual method. Public virtual void display room info. Because we have this virtual modifier here, we can now override this. So public override this public override this. So we've overading the display room info in both the standard room and the suite. So here, we've written a separate implementation of this method to behave the way we want it for standard rooms, and then a different way for Suit. So That is how that is basically what polymorphism is all about. You have different methods or sem methods behaving differently, just like animals who maybe people who cry or animals who make a sound. The sound of a cat and that of a dog is going to be different. So they all sound. Here, we're seeing a display room infod same as the display room ind in the standard room, and as the display room infod in the base class, which is the room class, implemented differently, but with the same name. That is polymorphism. If we use, now, when we talk about polymorphism, there is in EPEx, there's what we call a run time polymorphism, and then I runt polymorphism, that is what we have here. We are overriding these methods. In each of the classes, and then we are instantiating them and calling the specific methods in order to display the information. The other type of polymorphism is compile time polymorphism, which is basically one of the things we looked at when we talked about constructors. You can have different constructors that are overloaded. Here, you can see we have a reservation class with different same methods, but different parameter list. This is typically an overloaded method. We have book room with only the room number. We have book room with room number and guest name. We have another method, same method with room number, guest name, and check in date. So what happens is that you can instantiate a reservation either by using the room number, the room number, and guest name, or the room number, guest name, and check in date. This is typically what we refect as compile time polymorphism. This is an example of the implementation. Here, we have the different book room implementation, we have a reservation class. So we have public void book room. So that's the first constructor with one parameter. Second constructor, or second method with another parameter is basically same method name, but different parameter list. Another method, same method name, also a different parameter list, and each one of them behaves differently. You can see each of them returns different outputs depending on what you passed on. So that is if once she creates a new reservation object, you're calling the overloaded methods. So this is the first one with just the room number. This is the second one with the room number and the guest name. Then this is the third one with the room number, guest name, and checking date. So it will return different outputs based on their instantiation. Any questions here? One of the benefits of polymorphism in any programming language is basically it allows you to reuse your code. It also offers you some flexibility as well as maintainability within your code. If you want to reuse code, basically, you can have one implementation in your base class and then a different implementation in your subclasses. But you can just define your base method as a venture method and then override them in the subclasses to give you some flexibility as to how each one of them is going to behave in each of the classes. Lastly, we want to look at how do you apply this in a real world enterprise application. So all of this knowledge, all of this stuff we've been talking about, how do you apply that in a real world enterprise application? The first thing will be we're looking at customer management. So you have like we've looked I think in week four, we created the data model for the hotel reservation app. So you can use that to be able to look through all the data that is stored for a particular object or multiple objects, and then try to retrieve those data. We'll look at retrieving those data next week. Now we talk about enterprise system or data programming. Here we have a customer class, and we have a constructor which instantiates a customer object. So we are passing the customer ID, the name of the customer, and the e mail. And then here we have another method that displays the customer information. So we can now implement this particular class by instantiating it. So we instantiate this class, we call it customer, create an instance of the customer class, and then pass these parameters in the customer ID, the name, and then the e mail. And then we call. So we call, we use this object instance to call the method in this particular class, which is display details. So this method would then display this information. In some cases, you will also probably look through a list of records, which we'll look at next week. So you look through a list of records and check if a record contains a particular value or a particular name, then you do something else. For example, let's say someone enters an e mail address that is not stored in the database. First of all, you could just look through customer or guest or whatever record you have that contains e mail records. So retrieve all the e mails, look through that record. Check if the record or the value that the user entered matches anything in your database. If it is not, you display one information to the user, otherwise, you do something else. So that is using some kind of SQL or query language to query the object database, retrieve those information and then look through them to check if it matches a certain record that is of interest to you. So that's one implementation example. The other one is handling customer orders. One of the things we did from a no programme point of view is basically a customer goes on, sends an e mail. We create a case, and so on. There are other ways that you can also handle an order. Now, later on, we'll look at how you could use a virtual assistant to create someone can just log on online, chat with a virtual assistant to create an order or book an appointment without having to call a customer service. Those are some of the things that you can achieve from a programmatic point of view. Here we have an, a normal order class with the instance variables, the constructor, as well as a display or info that displays information about the order. Then once we create an instance of this class, which is basically a customer. So you can see, we already have a customer class here. So we're creating first of all an instance because every order has to be associated with a customer. So we're creating an instance of a customer, and then we're then creating an instance of the order and we're adding the customer record to that order. So once we do that, we then call the display order info. So you can see that the constructor here also takes in a customer object or a customer value. So we have a customer. So first of in order to pass in this particular parameter, we need to first of all create a customer object. Once we create a customer object, we can then pass in this customer variable to our or as a parameter to this constructor. And then we call the display or info and it will print ds. The last one, we want to look at is managing customer subscription, which is one way you can also use some of the OOP concepts we've talked about to apply to a reward enterprise application. So we have, first of all, need to, first, we need to create an extended customer class. Because if you look at a customer class, there are a few things that are not contained here. So we need to create an extended customer class to include things like address, sting, post code. And then we create a constructor that instantiates this extended customer, and then we create a display method that takes into account the additional instant variables that we have added. So Then once we do that, we can then create a subscription class. First of all, we have an extended customer class. We have a subscription class. So we have a subscription class has a subscription ID, a start and end date as well as a customer variable. And then display subscription information. So once we do that, we instantiate. So here, we first of all, instantiate a customer, that's an extended customer, and then we instantiate a subscription, and then pass the customer as a parameter to that subscription constructor method, and then we call the display subscription info, which is this one here. This we definitely write subscription ID, I will write the ID that we've passed in here. Start date, it will write this date, end date, it will write the end date and then customer. So you can see that if you look at the customer here, we're only interested in the name of the customer. We're not interested in everything. So we're using the dot notation to return just the name of the customer. Once we instantiate this customer, whatever object name we have here, which is the customer. Of the name. We can use that using the dot notation to return whatever name we've passed. So we're not interested in e mail address, C postcode. We're only interested in the name. So we are returning whatever name that is passed here, which is David Wilson. So that is how this is going to be displayed. Now, there are a whole bunch of things we can do, especially if we're using some DL or DML statements in which case, we're checking conditions and then we're writing this data into the database. We'll look at that next week. Okay. I think that's everything we have for today. Any questions? Any questions, whether or any assignment, whatever. All right. So if there are no questions. Thank you very much for your time. I'll see you again next week. Okay."
//                , "400", 5 );


//        System.out.println("Message 1:");
//        manager.fetchChatResponse("Use as many quotes as possible. Today, we want to discuss a very important aspect of enterprise systems development from a coding point of view, really, which is object oriented programming. I believe many people are familiar with OOP. For example, if you are in computer science or you know Java or CSA programming, you probably are familiar with that. Object oriented programming is a very important aspect of enterprise system development because previously we have talked about business objects. Everything in a business is looked at through the lens of an object. But it is also important to understand how you can instantiate these objects from a programmatic point of view. That is what we want to talk about today. What is OOP. Technically, Through the lens of OOP, programmers see everything as an object, a cheer, a person, invoice from a business point of view, even a flower, an animal. So each one of these have characteristics. So for example, a person have skin turn, a person have height, they have weight, and then you look at it from another perspective, from a behavioural point of view, a person can speak. A animal can walk, they can talk. This could be seen from a method point of view. Object programming is more like a paradigm that gives programmers the ability to view entities through an object lens. So we will look at some examples in our own context, as well as how they can be applied from an enterprise systems context. There are a few key concepts. When we talk about object oriented programming, there are a few key concepts that you cannot do without, which is the concept of classes and objects. We've talked about objects, but classes are from a programmatic point of view. Then there's cocation, inheritance, polymorphism, as well as abstraction. We will touch on some of these as we progress in our discussion today. So Let's look at what is an object. Now, when we talk about object, like I said, we're talking about entities that have attributes or characteristics. So what do you mean by attributes? Attributes are like your properties, your height, the colour of your skin, attributes are like your weight. If you look at it from a business object point of view, we'll see name, a student has a name. A students have an ID, an e mail address, a location, address, and so on. So those are attributes. So objects they are different viewpoints from an object point of view. So you can see different authors have come up with different definitions of what they conceive an object to be. So Code and Udon talks about object as an abstraction of something in a problem domain reflecting the capabilities of a system to keep information about it, interact with it, or bod. And then you also see others who view it as a collection of data and associated behaviours. From an enterprise system point of view, you could view object as the later definition, which is basically a collection of data, and then the behaviours. So we're looking at information that is stored in a database, and then what those entities can do and what actions can be performed on those entities. So let's look at a typical example which from a business point of view, we all know, which is a customer. In the business domain, one of the key objects within any business information system or management information system is the customer. So you want to capture information about the customer. The customer will have attributes or the object data, as we refer to it. So we have the customer ID, the first name and last name, e mail phone, and any other information you want to capture about the customer. Then there are also object behaviours. These are actions that the object can perform, or in some cases, actions that can be performed on those objects. So here we see the customer can place order. The customer can also make payment and order. Behaviours that can be associated with a customer. So Put it simply and object represents an entity within either a software development context or a business context. Let's look at the difference here. If you recall, we have talked about business object, which is one of the things you're doing in your assessment. But how is it different from object from a generic computer science or programming point of view? So business objects are business driven. So these are entities that are real word entities from a business point of view. Your customers, your invoice, your order, all of those are business related. So that is one of the key differences between the objects from a software point of view and then the objects from a business point of view. So the objects in a business context are business driven. So in most cases, they are seen from a domain point of view. So they store records in the database, also are used to manipulate or to develop business processes, as the case may be. So they serve as higher level abstraction for modelling business operations. So they are not typically seen from a technical implementation point of view. But from a software point of view, you see an object They are basically instances of classes that carcelate data and behaviour. Anything can be conceived as an object from a software point of view. Then objects in a software domain are not typically associated directly with database tables. When we talk about objects in a in a business point of view, these are information that businesses store, and then they can retrieve those information and do something with it at a later date. But you can have your object from a software point of view, which are just programmatically defined. But here, these are basically reward entities that businesses interact with on daily basis. These are a couple more differences between the objects in OOP as well and then business objects. If you look at it from a proposed scope implementation point of view, you will see a few differences that exist between business objects and software objects. Any questions at this point? All right. So you cannot talk about objects without talking about classes. Now, I believe some persons probably did wonder when we're talking about business objects, and then we talked about business object modelling. And then the diagrams looked like a class diagram. Why didn't we call them class diagrams. We didn't call them class diagrams because we are talking from an enterprise application perspective. So from a business context, we look at those as objects, not classes. So we talk about classes from a programmatic sense. So when we're talking about programmes, you define classes, methods, class attributes, and so on, that is from a programmatic point of view. But if you're looking at it from an enterprise system or from a business point of view, you look at the trade lines of an object. So in most cases, from an enterprise system point of view, the objects are used to instantiate classes, or the classes would have to instantiate objects within the business domain. So a class is typically, there are different definitions you probably might see, but a class is like a template. That I think is the most simplest definition. It's like a template for an object. So look at a class as Your building plan. So to build a house or direct a building, you need to have a plan. It is from that plan that the house is designed. So you can design multiple houses based on one single plan. That is what a class is. For those of you who make cookies at home, look at the class as the cookie cutter, basically. You can have multiple cookie cutters that different shapes of cookies from the same cookie dough. So that is typically what a class is. A class is like a template. It defines the name, the attributes, as well as the behaviour of object. It is from this class template that we create or instantiate an object. So if we have a class, say a customer class that defines the attributes of a customer to include the ID, the first name, last name, e mail, and phone. Then each time we instantiate or we want to create an object, a customer object, say customer one, a customer two, whatever customer instantiation we want to create. So that would have to be formed based on the definition contained within the class. So to better understand the class, let's look at this. Let's say you have a cook, and you need to You need to create multiple cookies. The cookies are the objects. But the cookie cutter is your class template. It is what is used to cover different shapes. You can have different shapes of cookies cut out from the same dough. That is typically how a class. You define a class and then you create objects based on the definition of the class. So Let's look at how you create a class or an object from a class. Let's say we have our customer class. And we have defined that our customer class has about five attributes, a customer ID, a first name, last name, e mail, and a phone. So this is our template. We can use this template to create different customers. So One customer will be customer 0001 with customer ID 0001, first name John, last name, e mail John do at email.com, and then a phone number. So we can also create another object from this particular template. So here we have our customer ID to be 0002. First name look, last name Happer, e mail, and then phone. So we could create as many instances of this class as possible, which are typically objects. So if you look at the learning management system that many universities use, there are multiple students that the information is stored in those systems. So typically, there is a student class that each time a student enrols into the university, a record of the student is created. So what record is created is determined by the template, which is the class. So what information is supposed to be contained or the entities or the attributes that are contained within the class definition determines what information is going to be required from a student record point of view. And questions from here. We've talked about objects and classes from a very generic point of view. We want to look at this from a language specific lens. All this while we've been talking about APEX programming language. This is how a class is defined in e. Now, what you see on top here, Those are the assess modifiers. Assess modifiers can be private, public, or global. Now, private is basically when you don't want that particular class to be instantiated from outside of your organisation. You can make it public, for example, if you want to expose it, or you can make it global. Global in EPE is used mostly if you want to expose a class as a web service. So we will do web services when we talk about APIs, which will also feature in one of the tax in your assignment two. So each class, when you want to expose a class as a web service, it must be defined as global using the assess modifier global. We will look at that at a later date. Then you can also have sharing modes, There are different sharing most virtual abstract, with sharing without sharing. Now, this may not apply in some other programming languages, but in APEX. You see that this are very much common across many object oriented languages. Java, C sharp, and the rest. But with sharing and without sharing, I think is a bit more specific to the EPEC programming language. But what does each one of these mean? I'm sure you probably if you're familiar with Java and C sharp, you understand that the virtual So when you want to override a class or override a method within a class, you can then define that method or class as a virtual method so that you can write a different implementation of that particular method or class. But with sharing and without sharing works a little bit differently in APEX. When you define a class with sharing, it means that you're limiting that particular class or the behaviour of that class to the users access level. Each time a user creates a class. Whatever access level you have on that particular system would determine the behaviour of your class. For example, if you create a class and you define it with sharing and as a user, you can only change 30 or 20 records at a time. So let's say you have defined a class or a procedure within the class to effect 50 records But the user access level only limits that particular user to 20 or 30 records. That class that operation will only be limited to the number of assets or the number of operations that the user can perform based on their assess level. This is called user mode with sharing. It inherits the access level of the user, and then that determines the behaviour of the class. If you define it without sharing, that is a system mode, in which case, regardless of what access level the user may have, then the class will perform the functions or the operations that are specified within without any limitations based on the access level. Then within a class, we have a class name as well as the body of the class. This is basically the syntax for defining a class. Each one of these Access modifiers and sharing modes have different functions? The private, the public, the global, like I said, mostly used when you're creating we services, and then you have the with sharing without sharing, as well as virtual when you want to override a class, then you have to define that class as a virtual class so that you can create a separate implementation of the class maybe in a different context. Any questions from here? The other thing is within a class, we can also have multiple methods. A method defines the behaviour of an object. Whether you want to add records, delete records, and so on, those are defined within methods. In EF, Methods are defined using this particular syntax. You see the access modifiers, whether it is public, private, protected, or global. Then you can you can also define it as either override, static over varieties, basically when you're overriding a particular virtual method that is defined in a different class. And then you have the type, which is the return type. Now, methods can have no return type, in which case it is a void method. Then you can also have a specific return type, which case you have to define the data type that it's going to return. Could be a string, a decimal, a bulion, or whatever data type that you want to return. Then you have the parameters. The parameters, in some cases, could take as long as 32. That's the most method can take in PEX. But you can also have no parameters at all, in which case, you have to include an empty bracket. So this is a typical method. So a public static integer. So the data type here is integer. So it is returning a value, which is of the integer type. This is the method name, and then you can do some calculations or implementations in the co braces. So within the cobrass, you can define how this particular method is going to behave. Many operations that are performed with you're deleting, you're checking when someone deletes a record, you want to check If they actually meant to delete that record, those are basically defined within methods. Another important concept when it comes to class and method definition is constructors. What are constructors? In object oriented programming, one of the things we talk about is your ability to instantiate. So we looked at a class as a template. But how do you create programmatically, how do you create an object of that template? You need to instantiate that particular class. What helps you to instantiate the class the constructors. By default, we have the new argument constructor, which is basically a method with the same name as the class name. So here you can see public order, and then we have a class public class order. So the method name has the same name as the class name. Sometimes you can define how this particular constructor behaves. But if you do not define a constructor, it takes the default form, which is the no argument constructor. So that is why each time you instantiate a class, you can use the dot notation to retrieve the attributes within the class instance variables, and then you can assign the method or the object its properties by using the dot notation. So what allows you to do that is the new argument constructor. Now there are also times when you want to define a specific number of constructors or a specific number of parameters within your constructor. So that's where you have the overloaded constructor. First, here we have the new argument constructor, and then here, you can see that we have same method and class name. So this is a constructor. This is another constructor, but the difference between the first and the second is that in the second, we have the constructor, we have assigned the constructor two parameters, a string parameter and a date parameter. Here we have overloaded this this constructor. What it means is that when you're trying to instantiate an order, you have to assign or specify the order ID and the order date. So each time you instantiate an order, you have to define or specify the ID, that's the order ID, and then the order date. So we've enable to these instant variables, which are the order number and the order date. So these instant variables here are equal to the parameter variables that we've passed to the overloaded constructor here. And then we're saying that these two variables here are also equal to the two variables we've passed in the overloaded constructor. Any questions here? So let's look at a class holistically. So we've talked about class names, constructors, as well as class methods. So putting all that together, we can have an or class with all the attributes, other ID, or date, total amount. These are the attributes we see in the class diagram, where we specify that an order can have an order ID, can be identified by the date of the order or associated with a total amount. And then we have a constructor, which is an overloaded constructor in which case we've passed three parameters, the order ID, the order date, and the total amount. Now, we've used the D keyword to reference these parameters here. Refer these attributes and then equate them to the parameters with pass in the order. What does that mean? Because we have or ID, the same name as the order ID in the parameter list. We need to be able to differentiate which one we are referring to. If we have them as different names here, and then we want to equate each name. So for example, let's say we have or number. And then here we have or ID. We can say or number is equal to other ID. That would be okay. But because we have the same instance variables that we've defined, same name with the parameter list that we've passed to this constructor, then we have to use the diskey word. The dis keyword down now refers to the instance variables. This the instance variable is equal to the parameter variable. So that is why we're using the ds. Otherwise, you can equally since we have defined the instant variables here, we can just say other ID que other ID. But because their names are the same, we can do that, so we have to be able to differentiate which one is which ones are the instant variables and which one are the parameter variables. And then this is a method, in which case, which saying display other details. Here we're trying to print Other ID is going to print an order ID. So the four slash and is a new line, which means each one of these will be printed in a separate line. These are the methods, we have our constructors, we have our attributes of the fields, we have the class name as well as the modifiers. In which case, this is a public class. Any questions? Here. Okay. Let's look at instantiating an object. If you look here, we have our order, and we've defined an order with three instant variables, order ID, order date, and total amount. We have a constructor that we have also defined. Which takes three arguments, O ID, other date, and total amount. And then we have another method which have defined to print or to display the details of the order. Let's say we have our first order. So the order date is OLD 001, and then we're saying the date is today, and the total amount is 250. In order to instantiate that particular class to create our object record, we have to say the class name followed by the name of the object. You can say the class name here is order. So we have to have to include the class name followed by the order name. Now, the name here can be anything. So long as it's associated with a class and then followed by a new order, which is basically a new instantiation of this particular constructor. You can see because we have a parameterized constructor that takes three parameters, we are passing three values here. The first value is the order ID, second value is the date, and then the third value is the total amount. We have two order records and we've been able to pass that or to create an instance of that class Using those values. Here, we're using the dot notation to retrieve. We're saying or do order ID. So this definitely will print out the order ID for order one. And then we're saying 02 dos or date, in which case is going to print this particular date here. So next we are calling, so we're using the dot notation also to call the display order details. Here is the display order detail. Once we have created an instance of this class, we can then use that to reference any of the methods that are defined within the class. So here we're calling the display order details, which has a print method or a print statement rather that prints out the order ID, the order date, and the total amount in a new line. So the first order will print this. The second one will print that. That's how you instantiate an object from a class definition. So you state the name of the class followed by the name of the method, and then you create a new instance of the class. If if the constructor is parameterized, then you have to define the values for the parameters. Otherwise, you can use the dot notation to assign different values to the object based on whatever value you have specified in your programme. Any questions here? Okay. The next thing we want to discuss is the concept of messages. In our previous discussion, when we talked about business objects. We talked about interaction diagrams, which is basically you see business objects or different entities, how they interact within a system. So one sending message and then the other responding with a response. So methods also do the same. When we have multiple methods within a particular system, what definitely happens is that we're passing or we're sending message from one method to another method. So we want to retrieve a particular order number, or we want to retrieve the D of a person or a student. We're passing or we're creating an instance of a method and we are calling a method that is defined in a separate class. So that is a message that we're sending to that method, and then that method we have to execute and return a response. So that is how messages work. Look at this particular instance. Let's say we have an order class and then a product. We're trying to purchase an item, but or we're trying to design a system that allows a user to add a product to an order. In order to do that, so we have our order class and our product class. And in the product class, we have defined how to add a product. In order to add that product to our order, we have to call that method within the product class. This is typically some of the message exchanges. So an order would have to add the product as well as get the price, and then the product we have to return the price as well as update the total amount because the price is within the product class. Let's look at it from an EP programme point of view. Here we have order and product classes, as we saw in the previous slide. We defined two instance variables, the order ID and the total amount. The total amount, we have initialised it to zero. In the other class, we have another method called add product. Then we also have another method called get total amount. Here, add product, this is the behaviour of this particular class, and then get price, which is basically trying to re the price of a product. If we look at the product class, we also have two variables, product ID and price, and then we have a constructor which instantiates a product. So each time we want to create a product, we have to use this constructor to create a product instance. So this instantiates the product, and then we have another that gets the price of the product, which is basically returning the price of or whatever price that you defined for the product. So if you look here, When we instantiate this particular, the two classes. We have an instance of a product, product one, and we're passing the product ID and the price because that is the definition. And then we have our order, which is the order ID here. Sorry. So you can say we're adding a product, and we have just one single parameter for this particular art product method. Here we are instantiating the two classes. The product class and the order class, and then we are calling. The order is sending a message to product. You can see the ad product has a parameter called product one, which is the one we have defined here. And this is defined in the product class. The product the constructor that creates the particular product is defined here. Is defined here. This is where the product is defined. In order for us to add the product, we need to first of all, create an instance of that particular product. So here, the order is calling the ad product and which sends a message to the product to add a product to the order. And then here we are then printing out the product, so you can see product one dot get total amount. Get total amount is also another method within the or class. So you can see the back and fort, how object sent or method send messages to another method, which we then return a response. When we call up, when we send a message from when the order sends a message to the product, the product will have to instantiate this particular product and then add that product to the a product method, which is defined within the order class. Any questions here? Next up, we're going to discuss how you implement classes and methods using a sample application. Before that, I will let you go for a 5 minutes break. So when we come back, we continue. The next thing we want to discuss is a typical implementation using a sample hotel application scenario. Previously, we have looked at different objects within a hotel application app, a guest, a reservation, a room, and some other objects. We'll just pick this three for reference proposes. If you look here, you'll see that we have a guest Object has about four attribute, guess ID, first name, last name and phone? We have a reservation object, which has a guess name, checking date, checkout date, and then information about the room. We also have a room object, which has a room ID, the type of room, and then the price of each room. So how do you instantiate each one of these as an object? Programmatically. This is the first. First of all, each one of them would you have to create a class for each object, a guest class, a reservation class, and then a room class. To create a room class, we have to start with the public. Now normally, this is optional, but if you don't include it, I think it will take the private Identifier. So here we have a class definition. We have the instant variables as the room number, the type of room, and the price of the room. And then we have a constructor that defines how this room would have to be instantiated. So we are passing three parameters here, the room number, the type of room and the prize of each room. Then we're using the dis keyword to relate the instant variables to the parameter variables. This is basically a room class. Now you can also define further methods that perform different actions depending on what you want to achieve. The other thing is our guest class. Now, in the guest table, we have a guest ID, first name, last name and phone. Here, we have those as instant variables. Here, we have a guest ID, first name, last name and the phone. And then we have a constructor that defines how this particular guest would have to be instantiated. And then we have displayed guest info that defines how the guest information is going to be displayed on the console. The other thing is further, we have a reservation class. So each of the objects are now classes in our programme. So we have the instant variables, which are the attributes or the characteristics of this particular reservation, guest ID, checking date, checkout dates, and room. And then we have a constructor as well as a display reservation method that displays information about the reservation. So putting all that together, we can then instant shear a different object. So we have a guest, so we're creating a new guest, and then we are passing the guest ID, the first name, last name, and the phone. We are creating new rooms. So we have to state the class name followed by the method name, which in this case is room one oh one, and then we instantiate a new room and then we pass the parameters we specified in the constructor, which is the room number, or the room ID, the type, and then the price. Same thing with a second instance of the room, which is room 102. Then we're adding, so we have this we have another hotel, which I did not include another hotel class, where we're adding these rooms to the hotel class, say add room method within the hotel class. And then we then have a reservation. A reservation, we then create a new reservation where we're adding the name, the date. Of the reservation. Now, in EPEC, if you want to create a date, it is called date dot today. So today's date. If you want to create yesterday's date, you have to subtract the number of days between today and that previous date. So it will be today minus say, for example, if you want to create a date from yesterday, it will be today minus date dot today minus one. So this will basically specify the date of today and then remove one day from today's date, which will give you yesterday's date. On a second. Then if you want to create a date in the future, so that will have to be the date. So today will be the reference date, and then you can add the number of dates from today up to that particular date. Yeah. Well, the room numbers are In some cases, they can be auto generated. That is if you have defined your object to auto generate room numbers. Otherwise, you can also generate the room numbers programmatically by manually or hard coding them. There are different ways to generate a room number. One way from what we've done so far, so you can create an object and then define that the room numbers are auto numbers. What that means is that each time and object is created, you don't have to manually create a room number. The system will auto generate that particular number and assign it to that room. So you don't have to do that. Another option is for you to hard code each room number. So here we're basically hard coding the room numbers. But under normal circumstances, you may decide not to hardcode the room numbers and then make them auto generated. Here then the last thing is basically we're displaying reservation information, which is calling this particular method. So we're using the reservation object to call my reservation, which is the object instance of this reservation class, and then we're calling the reservation to display the information about the guest name, the room number, check in date, as well as checkout date. This will be basically the output of this particular programme. So here is our guest instance of our guest one oh one, room one oh one, and then our reservation. Checkout date for this reservation is three days from today. Check in date is today. The other thing you can also do is extend a class. You could see here that we have multiple classes. But a class can be limited in function, and you can extend the classes at any point in time by adding either a new instance variable, a new method, and so on. Here you can see we have introduced a hotel class, in which case, we have the name of the hotel, the location, a list of rooms that are contained in the hotel. We've also introduced a rating the hotel as well as amenities that are contained within that particular hotel. And then we have a constructor which specify how we instantiate this particular class. We have another method that adds room to the hotel, and then we have another method that displays the hotel information, and then another method that gets the total number of rooms in that particular hotel. You can see we've added multiple methods to this particular class. This is the class definition, the instance variables, the constructor, and then three other methods, one to add the room, the other one to display the hotel info, and then the other one to get the total number of rooms for that particular hotel. The second thing we can also do is extend a room class. You can see here we've added another variable that checks whether the room is available. And then we've also added a view for that particular room. So there are rooms that have specific views, and those views might be one of the reasons people reserve them. So we've added the view here. And then here, we have a constructor that defines the room or how the room is instantiated. We have another method that display or that books a room. And then we have another method that displays the room information. So we can then try to instantiate the hotel and the room class using the extended classes. So here, first of all, we're creating an extended hotel object. We're creating an extended hotel room object, and then we're adding rooms to the hotel. We're displaying hotel info. We're displaying room info and booking a room. And then finally, we are getting the total number of rooms in the hotel. So this will give us these results. So the hotel is Sunrise in, Location is downtown, rating is f, amenities three wi fi, pool and gym. And then we have the display room information, which will display the information about the room, the type of room, the price, whether the room is available, the room view, and then also display whether the room is booked or not. So this is basically how you can extend a class and then instantiate that particular class by creating multiple objects and then using the instance of those objects to call the methods that are defined within the class. Any questions from here? Okay. If you have dealt with object oriented programming, one of the things you basically would have gone through at the different concept, the concept of inheritance, polymorphism, and so on. So we want to discuss a little bit of how those are implemented using the APEX programming language. So we talked about inheritance. I think we've looked at it from an object modelling point of view where you're using arrows to indicate whether a child object is inherited from a parent object. So inheritance gives you the ability not to reuse your code. So for example, Within the KeyT environment, everybody here is a person, whether you're a lecturer, a student, and the registrar, ahead of department, ahead of school, whatever role you play. There are some information that are common across every person. For example, there is a first name associated with someone, a last name, data ba, address, e mail, and so on those are generic, more like common attributes that can be associated with people. Now, depending on the role you play, If you are student, you have a student ID. If you are staff, you have a staff ID. So you can see student ID is specific to student, staff ID is specific to staff. If you are staff, you have salary from a payroll point of view, a student don't get paid. So all of that, Some of the things you have to take into account when you're creating a system and how you instantiate a particular system or inherit objects or classes within that particular system. You don't want to repeat. For example, you're creating a student class, a staff class, and so on, and then you're repeating all the attributes across all the classes. You can use inheritance to shorten or to reuse some of the codes. So you create a parent class that contains the base the common information that all common attributes, you can find across all the classes, and then you create the child classes that inherit the parent, but retain specific information for those particular classes or objects. So this is if you look at a room, for example, a room may have different types. A single room or a double room. Now, you'll see here that a room has information that is common regardless of what type of room, the number of the room, the type of room, and the price. This is common. But if it's a single room, You want to indicate the view, or if it's a double room, you want to indicate whether it has a balcony or not. So it means that a single room does not have a balcony, but a double room has a balcony. So to be able to indicate that or to check whether a room has balcony or not, basically has to be associated with a double room. And then you can creates a specific instantiation or specific implementation of the display room info. We have a method that displays specific single room information that is specific to the single room, and another method that is specific to the double room. These two methods are not the same, so we cannot put them here. Otherwise, if we put them in the room class, then both the single and double room will inherit them. What it means is that Regardless of the fact that we have these as separate from the room, the double room will inherit the attributes that are common to the room, which is the room number, the type and the price, as well as the single room inheriting all the common attributes and methods that are specified in the room, but retaining the specific methods that are specified in the child classes. This is the room the single room and the double room from an apex point of view. Here, we have a room. This is a normal room class. With three instance variable room number type and price, and then we have a constructor. Then we have a display room info. This is common to this two. Now, we have another class. We have a single room class, which is a subclass. This is the main class or the base class. We have another subclass which is this double room. In order to inherit or extend this particular class, in the child classes or the sub classes, you use the word extend. So extend we're extending the room class. So we say public class, single room extends room. What it means is that they will now be able to give the single room access to all the instance variables and methods that are defined in the base class, as well as double room. Then you can also see that we have display double room info, which is specific to the double room. We have display single room info, which is specific to the single room. These two methods are different. That is why they are contained separately in each of the subclasses. But the instance variables as well as the display room info are all available in case you want to call them from the subclasses. So this is typically how we can be able to instantiate, so we can create a single room object by calling the single room class followed by an object name in this case, single room. And then using the new keyword, we're instantiating a single room. And then we're displaying the single room information by calling this particular method here. The next, we're creating a double room object, and then we're displaying double room info by calling this particular method. I will display double room information. This will be the output of the two instantiations and display. Any questions here? The other OP concept, we want to talk about is encapsulation. Now, In your object diagram, we have told you not to use the visibility symbol, which is basically whether I include a minor surplus before an attribute name. That is typically a form of encapsulation. Here you can see if you look at the modifiers we mentioned earlier, which is whether it's public, private, virtual, global, and so on, those define encapsulation. You want to be able to hide the implementation of a particular method or class from someone else, so they won't be able to have access to see or to change how that particular method or class behaves. Here you can see the minus sign means a private attribute. The plus sign here denotes a public method. In some cases, you will also see attributes that are indicated using a plus sign, which indicates a public attribute. Now, if you do not indicate the modifier, in most cases, it will take a single a private state. Here you can see calculating a banking system. We have another example from a bank account. So we've defined these account number and balance. Now, in typical systems, you probably see fields that are read only. This is this is very much related to some of those fields that you see, they are read only, so you cannot modify them. For example, as a user, as a student, you cannot change your student number, even if you wanted. As a bank customer, you cannot modify your balance, even if you want it. So even if you want to assess the bank system through an API call, those are encapsulated because you cannot understand it. They kind of make it private so that you don't understand how or you don't modify those attributes, you don't modify the methods or how they behave. So here we're trying to encapsulate the implementation of some of these by declaring them as private. And then you can see some other methods here are defined as public, and then some attributes are defined as private because you don't want any system or any implementation from outside of your organisation to make changes to those parameters or those variables. The other thing is also using getters and setters. If you're familiar with C sharp, this is very much one of CSA features. Using getters and setters. Getters and Setters gives you the opportunity to manually define how a particular attribute is going to behave. So for example, you want to assign a value to an attribute after checking a particular condition. So the getters and setters will help you to do that. So the getters return information while the setters define a value for that particular attribute. If you look here, you will say We have a product class, we have defined the product name to be a private attribute. And then we have an explicit ga which returns, so you can see here. The product name is private, but we have a ga method that returns, which is now a public method that returns the name of the product. Ordinarily, you wouldn't be able to assess the product name directly from another application, but you can call the G product name in order for it to return the product name. Here, to be able to return this name, you can add additional logic. They are basically checks, different criteria, different conditions before returning the name. This gives the programmer control over how each of these methods behave. What happens, or what should happen before a product name is returned. You can also set a product name. Here you can see this does not just set a name, it first of checks if the product name is not null, and then the length of the product name is greater than zero. So if it is not null and then the length is greater than zero, then it will set the product name to whatever name that is passed on here. So it doesn't set a name if it has a name already. But it will first of all check if if the product name null, Is the name that you pass here greater than zero. So if you don't pass any record at all, it's not going to set an empty name. You have to first of all, check if you passed a name value. Also check if the product name is not null before it sets this name and then prints. Otherwise, product name cannot be empty. So first of all, if you have not passed any name here, then you get this message. Otherwise, it will set the name of the product. There are also automatic getters. Here you can see, these are explicit getters and setters. But you can have automatic gators, which is basically you create a method and you just put the gat and set. These are auto gas and setters. You don't need the auto implement. Now this is very a feature in CSA, if you're familiar with the programming language. So One other implementation that we want to talk about. This helps you to either. Now, if you don't have to define, if you don't have to define how each of these methods behave, you don't want to check a particular condition before assigning a value to a parameter or a variable, or you don't want to check a particular condition before returning the value of a variable, then you can use auto gatas and cts. Otherwise, you have to use explicit gas that gives you the control. Over how each one of these behave, when do you return them, when do you set the variables and so on. Any questions at this point? Okay, so we want to talk about polymorphism. I'm sure many of us have heard about polymorphism. Now, polymorphism in Apex is implemented mostly using the virtual modifier. You have different methods in different classes that behave or similar methods in different classes that behave differently. For example, you can say if we go back to our room object, and then we have a standard room and a suite. These are different types of rooms. This is the parent or the base class. These are the sub classes. We have a suite is a type of room, a standard room is a type of room. Then in the base class, we have attributes like room number type and price, and then we have a display room info. Typically, you can define this particular method as virtual, which means you don't have to technically write a full implementation of this method. You can overwrite the method in another class. So then we can then override this method. Overriding the method, we have to include the override keyboard. And then in which case, we want to you can see display room in display room info, display room info. Same method, but different signatures. Because the way we want this to happen, so we want each of the types of room to have a separate display. So they will be displayed separately depending on what information we want to display about the room. The standard room info display will be different from the suite room info display, but they have the same method name. By defining the display room info in the parent class as a virtual method, We can then override it, which is write a separate implementation of this method to behave one way for standard room and another way for a suite. So here, you can see a room class, a standard room class, with the three instance variable. A constructor, and then the method that displays room info. This is the method, and here we can see it's been defined as a virtual method. Public virtual void display room info. Because we have this virtual modifier here, we can now override this. So public override this public override this. So we've overading the display room info in both the standard room and the suite. So here, we've written a separate implementation of this method to behave the way we want it for standard rooms, and then a different way for Suit. So That is how that is basically what polymorphism is all about. You have different methods or sem methods behaving differently, just like animals who maybe people who cry or animals who make a sound. The sound of a cat and that of a dog is going to be different. So they all sound. Here, we're seeing a display room infod same as the display room ind in the standard room, and as the display room infod in the base class, which is the room class, implemented differently, but with the same name. That is polymorphism. If we use, now, when we talk about polymorphism, there is in EPEx, there's what we call a run time polymorphism, and then I runt polymorphism, that is what we have here. We are overriding these methods. In each of the classes, and then we are instantiating them and calling the specific methods in order to display the information. The other type of polymorphism is compile time polymorphism, which is basically one of the things we looked at when we talked about constructors. You can have different constructors that are overloaded. Here, you can see we have a reservation class with different same methods, but different parameter list. This is typically an overloaded method. We have book room with only the room number. We have book room with room number and guest name. We have another method, same method with room number, guest name, and check in date. So what happens is that you can instantiate a reservation either by using the room number, the room number, and guest name, or the room number, guest name, and check in date. This is typically what we refect as compile time polymorphism. This is an example of the implementation. Here, we have the different book room implementation, we have a reservation class. So we have public void book room. So that's the first constructor with one parameter. Second constructor, or second method with another parameter is basically same method name, but different parameter list. Another method, same method name, also a different parameter list, and each one of them behaves differently. You can see each of them returns different outputs depending on what you passed on. So that is if once she creates a new reservation object, you're calling the overloaded methods. So this is the first one with just the room number. This is the second one with the room number and the guest name. Then this is the third one with the room number, guest name, and checking date. So it will return different outputs based on their instantiation. Any questions here? One of the benefits of polymorphism in any programming language is basically it allows you to reuse your code. It also offers you some flexibility as well as maintainability within your code. If you want to reuse code, basically, you can have one implementation in your base class and then a different implementation in your subclasses. But you can just define your base method as a venture method and then override them in the subclasses to give you some flexibility as to how each one of them is going to behave in each of the classes. Lastly, we want to look at how do you apply this in a real world enterprise application. So all of this knowledge, all of this stuff we've been talking about, how do you apply that in a real world enterprise application? The first thing will be we're looking at customer management. So you have like we've looked I think in week four, we created the data model for the hotel reservation app. So you can use that to be able to look through all the data that is stored for a particular object or multiple objects, and then try to retrieve those data. We'll look at retrieving those data next week. Now we talk about enterprise system or data programming. Here we have a customer class, and we have a constructor which instantiates a customer object. So we are passing the customer ID, the name of the customer, and the e mail. And then here we have another method that displays the customer information. So we can now implement this particular class by instantiating it. So we instantiate this class, we call it customer, create an instance of the customer class, and then pass these parameters in the customer ID, the name, and then the e mail. And then we call. So we call, we use this object instance to call the method in this particular class, which is display details. So this method would then display this information. In some cases, you will also probably look through a list of records, which we'll look at next week. So you look through a list of records and check if a record contains a particular value or a particular name, then you do something else. For example, let's say someone enters an e mail address that is not stored in the database. First of all, you could just look through customer or guest or whatever record you have that contains e mail records. So retrieve all the e mails, look through that record. Check if the record or the value that the user entered matches anything in your database. If it is not, you display one information to the user, otherwise, you do something else. So that is using some kind of SQL or query language to query the object database, retrieve those information and then look through them to check if it matches a certain record that is of interest to you. So that's one implementation example. The other one is handling customer orders. One of the things we did from a no programme point of view is basically a customer goes on, sends an e mail. We create a case, and so on. There are other ways that you can also handle an order. Now, later on, we'll look at how you could use a virtual assistant to create someone can just log on online, chat with a virtual assistant to create an order or book an appointment without having to call a customer service. Those are some of the things that you can achieve from a programmatic point of view. Here we have an, a normal order class with the instance variables, the constructor, as well as a display or info that displays information about the order. Then once we create an instance of this class, which is basically a customer. So you can see, we already have a customer class here. So we're creating first of all an instance because every order has to be associated with a customer. So we're creating an instance of a customer, and then we're then creating an instance of the order and we're adding the customer record to that order. So once we do that, we then call the display order info. So you can see that the constructor here also takes in a customer object or a customer value. So we have a customer. So first of in order to pass in this particular parameter, we need to first of all create a customer object. Once we create a customer object, we can then pass in this customer variable to our or as a parameter to this constructor. And then we call the display or info and it will print ds. The last one, we want to look at is managing customer subscription, which is one way you can also use some of the OOP concepts we've talked about to apply to a reward enterprise application. So we have, first of all, need to, first, we need to create an extended customer class. Because if you look at a customer class, there are a few things that are not contained here. So we need to create an extended customer class to include things like address, sting, post code. And then we create a constructor that instantiates this extended customer, and then we create a display method that takes into account the additional instant variables that we have added. So Then once we do that, we can then create a subscription class. First of all, we have an extended customer class. We have a subscription class. So we have a subscription class has a subscription ID, a start and end date as well as a customer variable. And then display subscription information. So once we do that, we instantiate. So here, we first of all, instantiate a customer, that's an extended customer, and then we instantiate a subscription, and then pass the customer as a parameter to that subscription constructor method, and then we call the display subscription info, which is this one here. This we definitely write subscription ID, I will write the ID that we've passed in here. Start date, it will write this date, end date, it will write the end date and then customer. So you can see that if you look at the customer here, we're only interested in the name of the customer. We're not interested in everything. So we're using the dot notation to return just the name of the customer. Once we instantiate this customer, whatever object name we have here, which is the customer. Of the name. We can use that using the dot notation to return whatever name we've passed. So we're not interested in e mail address, C postcode. We're only interested in the name. So we are returning whatever name that is passed here, which is David Wilson. So that is how this is going to be displayed. Now, there are a whole bunch of things we can do, especially if we're using some DL or DML statements in which case, we're checking conditions and then we're writing this data into the database. We'll look at that next week. Okay. I think that's everything we have for today. Any questions? Any questions, whether or any assignment, whatever. All right. So if there are no questions. Thank you very much for your time. I'll see you again next week. Okay.", "500", 10);
//        System.out.println("Message 2:");
//        manager.fetchChatResponse("Could you please try and explain that using pokemon terms?", "1000", 5);
//        System.out.println("Message 3");
//        manager.clearChat();
//        manager.fetchChatResponse("Did I just tell you anything?", "100", 10);
//        System.out.println("Message 4");

        Connection connection = DatabaseConnection.getInstance();
        UserAccountDAO userAccountDAO = new UserAccountDAO();
        userAccountDAO.createTable();

//        userAccountDAO.insert(new UserAccount("hudson@email.com", "Hudson", "Password1"));
//        userAccountDAO.insert(new UserAccount("lucas@email.com", "Lucas", "Password2"));
//        userAccountDAO.insert(new UserAccount("harrison@email.com", "Harrison", "Password3"));
//        userAccountDAO.insert(new UserAccount("1", "testUser", "1"));

//        UserAccount account = userAccountDAO.getByEmail("hudson@email.com");
//        System.out.println(account.getUserName());


        launch();

        userAccountDAO.close();

    }
}